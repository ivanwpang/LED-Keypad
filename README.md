1. What does your program do?  
The program turns on the LED at various brightness levels based on which buttons are pressed on the 4x4 keypad. First the program stores values of zero through nine in a global unsigned short 2-D array as a lookup table formatted to look like the 4x4 keypad. For example, the value 0 is placed on button 0, and the value 9 is mapped to button 9. All the buttons that are not numbers such as letters and other symbols are defaulted with the value 0. The program has three functions that are all void, timer_zero(), timer_two(), and scan_keypad(). Timer_zero() is for initializing the keypad timer that scans every 3ms, it sets the OCR0A to 187. The value 187 was calculated by (1 / 16MHz) * 256 which resulted in 0.016ms, which is too small. Setting the pre-scale to 256 results in 0.016ms * 256 = 4.096ms which is bigger than 3ms. Then, I did (256 * 3ms) / 4.096ms which resulted in 187.5 and I rounded it up to 188. OCR0A is 188 - 1 resulting in 187. The function then sets the timer to CTC mode, pre-scale to 256, and enables compare match A ISR. Timer_two() sets OCR2A to 249, the value of OCR2A was found the same as OCR0A except I am trying to find 1ms instead of 3ms. I got 1ms by doing (1 / ((6 + 1) * 100Hz) which resulted in 1.429ms and rounded down to 1ms. Then timer_two() sets OCR2B as OCR2A * whatever button is pressed on the keypad divided by 10. Then, it will set the pre-scale to 64, and enable the same interrupts. Timer_two takes the 2-D array as a parameter. The program uses the same code from the scankeypad function from the previous labs to determine which button is pressed and will turn on the LED at whatever brightness is picked. In the main, the program sets the 5th bit of DDRB to output. Then, the program will use two for loops to set ports D4 through D7 as output and B0 through B3 as input. Then it will set those same bits to high. The main will then finally call timer_zero() and sei() to enable the interrupts. There are three interrupts in the program, one that will make the program scan the keypad every 3ms, one that turns on the LED at varying duty cycles for various brightness levels, and one to turn off the LED. The program will run forever until power is lost.

2. What variables/registers does your program use? 
The program uses the DDRD register to set the data direction of Port bit D1 and D4 through D7 to one for output, the DDRB register is also used to clear the data direction of Port bit B0 through B3 to 0 for input. The program uses the DDRB register to set Port bit B5 to one for output. The TCCR0A, TCCR2A registers are used to set the timer in CTC mode, the OCR0A, OCR2A, and OCR0B, OCR2B registers are also used to hold the period and the duty cycle. The TCCR0B and TCCR2B registers are used to set the pre-scale value to 256 and 64. The TIMSK0, TIMSK2 registers are used to enable the compare match A and compare match B interrupts. The program also uses int i and j as iterators. X is a variable of type float used as a parameter for timer_two function. Another variable used is a 2-D array named keychar functions as a lookup table with the values of the buttons stored in it. 

3. What is the main algorithm/logic of your program? 
Before the main the program defines F_CPU to 16MHz and includes avr/io.h and avr/interrupt.h. Then, the program declares a global unsigned short 2-D array that functions as a look-up table for the values of the 4x4 keypad. Next, the program has forward declaration for the three functions which are timer_zero(), timer_two(), and scan_keypad(). The scan_keypad() function works the same way as in the previous labs. The only difference is that it calls the timer_two function instead of usart_transmit or play musical notes. The timer_zero() function initializes timer0 by setting OCR0A to 187, CTC mode, and pre-scale to 256. Then it will enable the Compare Match A Interrupts. timer_two() does the same thing as timer0 except OCR2A to 249, pre-scale to 64, and sets OCR2B to OCR2A multiplied by whatever button is pressed divided by 0, and enables both Compare Match A and B Interrupts. Inside the main, the program sets B5 to output, D4 - D7 to outputs, and B0 - B3 to input, and sets D4 - D7 and B0 - B3 to high. The program will then call timer_zero() and sei() to enable interrupts. The infinite while loop is empty. The program contains 3 ISRs, the first ISR is Compare Match A for timer0 that basically calls the scan_keypad() every 3ms. The second ISR is also Compare Match A but for timer2, and it turns on the LED whenever the duty cycle is greater than 0, and if not it turns it off. The last ISR is Compare Match B and it turns off the LED.

4. What external hardware connections did you make? 
The external hardware connection made was the 4x4 keypad on a breadboard. The Atmel Xplained Mini Board was connected to the breadboard with the keypad on it with 8 wires through Ports D4 through D7 and Ports B0 through B3.
